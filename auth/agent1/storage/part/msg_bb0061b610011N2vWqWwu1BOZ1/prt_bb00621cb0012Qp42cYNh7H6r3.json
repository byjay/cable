{
  "id": "prt_bb00621cb0012Qp42cYNh7H6r3",
  "sessionID": "ses_44ffa5ddfffechczCzZPVIn6Z0",
  "messageID": "msg_bb0061b610011N2vWqWwu1BOZ1",
  "type": "tool",
  "callID": "call_e457030e8d104b879856fc6e",
  "tool": "read",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/app/smart_orchestrator.py"
    },
    "output": "<file>\n00001| import subprocess\n00002| import sys\n00003| import time\n00004| import json\n00005| from concurrent.futures import ThreadPoolExecutor, as_completed\n00006| from typing import List, Dict, Tuple\n00007| \n00008| class SmartOrchestrator:\n00009|     \"\"\"ì§€ëŠ¥í˜• ì‘ì—… ë¶„ë°° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°\"\"\"\n00010|     \n00011|     # ë³‘ë ¬ ì²˜ë¦¬ê°€ í•„ìš”í•œ ì‘ì—… í‚¤ì›Œë“œ\n00012|     PARALLEL_KEYWORDS = [\n00013|         \"ê²€í† \", \"ë¦¬ë·°\", \"review\", \"ë¶„ì„\", \"analyze\", \"ê³„íš\", \"plan\",\n00014|         \"ì„¤ê³„\", \"design\", \"ì•„í‚¤í…ì²˜\", \"architecture\",\n00015|         \"ë³´ì•ˆ\", \"security\", \"ì·¨ì•½ì \", \"vulnerability\",\n00016|         \"ì„±ëŠ¥\", \"performance\", \"ìµœì í™”\", \"optimize\",\n00017|         \"í…ŒìŠ¤íŠ¸\", \"test\", \"í’ˆì§ˆ\", \"quality\",\n00018|         \"í’€ìŠ¤íƒ\", \"full-stack\", \"ì „ì²´\", \"complete\",\n00019|         \"ë³µì¡\", \"complex\", \"ëŒ€ê·œëª¨\", \"large-scale\"\n00020|     ]\n00021|     \n00022|     # ë‹¨ìˆœ ì‘ì—… í‚¤ì›Œë“œ\n00023|     SIMPLE_KEYWORDS = [\n00024|         \"í•¨ìˆ˜\", \"function\", \"í´ë˜ìŠ¤\", \"class\",\n00025|         \"ê°„ë‹¨\", \"simple\", \"ì‘ì€\", \"small\",\n00026|         \"ì¶”ê°€\", \"add\", \"ìˆ˜ì •\", \"fix\", \"ë³€ê²½\", \"change\"\n00027|     ]\n00028|     \n00029|     def __init__(self):\n00030|         self.agents = [\"agent1\", \"agent2\", \"agent3\"]\n00031|         self.max_retries = 3\n00032|     \n00033|     def rotate_account(self) -> bool:\n00034|         \"\"\"ê³„ì • ìˆœí™˜\"\"\"\n00035|         print(\"\\n[ROTATE] ğŸ”„ Switching to next account...\")\n00036|         try:\n00037|             subprocess.run([\"ag\", \"rotate\"], check=True)\n00038|             time.sleep(3)\n00039|             return True\n00040|         except:\n00041|             print(\"[WARNING] ag rotate failed\")\n00042|             return False\n00043|     \n00044|     def call_agent(self, agent_name: str, prompt: str) -> Dict[str, str]:\n00045|         \"\"\"ë‹¨ì¼ ì—ì´ì „íŠ¸ í˜¸ì¶œ (ì¬ì‹œë„ í¬í•¨)\"\"\"\n00046|         full_prompt = prompt if \"/ralph-loop\" in prompt else f\"{prompt} /ralph-loop\"\n00047|         \n00048|         for attempt in range(self.max_retries):\n00049|             try:\n00050|                 cmd = [\"docker\", \"exec\", agent_name, \"opencode\", \"run\", full_prompt]\n00051|                 result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8', timeout=300)\n00052|                 \n00053|                 # Rate limit ì²´í¬\n00054|                 if \"rate limit\" in result.stderr.lower() or \"429\" in result.stderr:\n00055|                     print(f\"[RATE LIMIT] {agent_name} - Rotating account...\")\n00056|                     self.rotate_account()\n00057|                     continue\n00058|                 \n00059|                 if result.returncode == 0:\n00060|                     return {\n00061|                         \"agent\": agent_name,\n00062|                         \"success\": True,\n00063|                         \"output\": result.stdout,\n00064|                         \"error\": None\n00065|                     }\n00066|                 \n00067|             except subprocess.TimeoutExpired:\n00068|                 print(f\"[TIMEOUT] {agent_name} - Retry {attempt + 1}/{self.max_retries}\")\n00069|                 continue\n00070|             except Exception as e:\n00071|                 print(f\"[ERROR] {agent_name}: {e}\")\n00072|                 continue\n00073|         \n00074|         return {\n00075|             \"agent\": agent_name,\n00076|             \"success\": False,\n00077|             \"output\": None,\n00078|             \"error\": \"Max retries exceeded\"\n00079|         }\n00080|     \n00081|     def analyze_complexity(self, task: str) -> bool:\n00082|         \"\"\"ì‘ì—… ë³µì¡ë„ ë¶„ì„ - True: ë³‘ë ¬ í•„ìš”, False: ë‹¨ë… ê°€ëŠ¥\"\"\"\n00083|         task_lower = task.lower()\n00084|         \n00085|         # ë³‘ë ¬ í‚¤ì›Œë“œ ì²´í¬\n00086|         parallel_score = sum(1 for kw in self.PARALLEL_KEYWORDS if kw in task_lower)\n00087|         simple_score = sum(1 for kw in self.SIMPLE_KEYWORDS if kw in task_lower)\n00088|         \n00089|         # ê¸¸ì´ ì²´í¬ (200ì ì´ìƒì´ë©´ ë³µì¡í•œ ì‘ì—…)\n00090|         length_score = 1 if len(task) > 200 else 0\n00091|         \n00092|         # ì¢…í•© íŒë‹¨\n00093|         needs_parallel = parallel_score > 0 or (length_score > 0 and simple_score == 0)\n00094|         \n00095|         print(f\"\\n[ANALYSIS] Task Complexity:\")\n00096|         print(f\"  Parallel keywords: {parallel_score}\")\n00097|         print(f\"  Simple keywords: {simple_score}\")\n00098|         print(f\"  Length: {len(task)} chars\")\n00099|         print(f\"  â†’ Decision: {'PARALLEL' if needs_parallel else 'SINGLE'}\")\n00100|         \n00101|         return needs_parallel\n00102|     \n00103|     def execute_single(self, task: str) -> Dict:\n00104|         \"\"\"ë‹¨ìˆœ ì‘ì—… - ë‹¨ì¼ ì—ì´ì „íŠ¸ ì‹¤í–‰\"\"\"\n00105|         print(\"\\n\" + \"=\"*60)\n00106|         print(\"  ğŸš€ SINGLE AGENT MODE\")\n00107|         print(\"=\"*60)\n00108|         \n00109|         result = self.call_agent(\"agent1\", task)\n00110|         return result\n00111|     \n00112|     def execute_parallel(self, task: str) -> List[Dict]:\n00113|         \"\"\"ë³µì¡í•œ ì‘ì—… - ë³‘ë ¬ ì‹¤í–‰\"\"\"\n00114|         print(\"\\n\" + \"=\"*60)\n00115|         print(\"  ğŸ”¥ PARALLEL MODE (3 Agents)\")\n00116|         print(\"=\"*60)\n00117|         \n00118|         # ê° ì—ì´ì „íŠ¸ì—ê²Œ ë‹¤ë¥¸ ê´€ì  ë¶€ì—¬\n00119|         perspectives = {\n00120|             \"agent1\": \"ë°±ì—”ë“œ/ë¡œì§ ê´€ì ì—ì„œ\",\n00121|             \"agent2\": \"í”„ë¡ íŠ¸ì—”ë“œ/UX ê´€ì ì—ì„œ\",\n00122|             \"agent3\": \"ë³´ì•ˆ/ì„±ëŠ¥/ì¸í”„ë¼ ê´€ì ì—ì„œ\"\n00123|         }\n00124|         \n00125|         tasks = []\n00126|         for agent, perspective in perspectives.items():\n00127|             agent_task = f\"{perspective} {task}\"\n00128|             tasks.append((agent, agent_task))\n00129|         \n00130|         # ë³‘ë ¬ ì‹¤í–‰\n00131|         results = []\n00132|         with ThreadPoolExecutor(max_workers=3) as executor:\n00133|             future_to_agent = {\n00134|                 executor.submit(self.call_agent, agent, task): agent \n00135|                 for agent, task in tasks\n00136|             }\n00137|             \n00138|             for future in as_completed(future_to_agent):\n00139|                 agent = future_to_agent[future]\n00140|                 try:\n00141|                     result = future.result()\n00142|                     results.append(result)\n00143|                     status = \"âœ…\" if result[\"success\"] else \"âŒ\"\n00144|                     print(f\"{status} {result['agent']} completed\")\n00145|                 except Exception as e:\n00146|                     print(f\"âŒ {agent} failed: {e}\")\n00147|                     results.append({\n00148|                         \"agent\": agent,\n00149|                         \"success\": False,\n00150|                         \"output\": None,\n00151|                         \"error\": str(e)\n00152|                     })\n00153|         \n00154|         return results\n00155|     \n00156|     def cross_review(self, results: List[Dict]) -> Dict:\n00157|         \"\"\"í¬ë¡œìŠ¤ ë¦¬ë·° - ê° ì—ì´ì „íŠ¸ê°€ ë‹¤ë¥¸ ì—ì´ì „íŠ¸ ê²°ê³¼ ê²€í† \"\"\"\n00158|         print(\"\\n\" + \"=\"*60)\n00159|         print(\"  ğŸ” CROSS REVIEW PHASE\")\n00160|         print(\"=\"*60)\n00161|         \n00162|         # Agent1 â†’ Agent2,3 ê²°ê³¼ ê²€í† \n00163|         # Agent2 â†’ Agent1,3 ê²°ê³¼ ê²€í†   \n00164|         # Agent3 â†’ Agent1,2 ê²°ê³¼ ê²€í† \n00165|         \n00166|         review_prompt = \"\"\"\n00167| ë‹¤ë¥¸ ì—ì´ì „íŠ¸ë“¤ì˜ ì‘ì—… ê²°ê³¼ë¥¼ ê²€í† í•´ì£¼ì„¸ìš”:\n00168| \n00169| {other_results}\n00170| \n00171| ë‹¤ìŒ ê´€ì ì—ì„œ ê²€í† :\n00172| 1. ëˆ„ë½ëœ ë¶€ë¶„ì´ ìˆëŠ”ê°€?\n00173| 2. ì¶©ëŒí•˜ëŠ” ë‚´ìš©ì´ ìˆëŠ”ê°€?\n00174| 3. ê°œì„ ì´ í•„ìš”í•œ ë¶€ë¶„ì€?\n00175| 4. í†µí•© ì‹œ ì£¼ì˜ì‚¬í•­ì€?\n00176| \n00177| ê²€í†  ê²°ê³¼ë¥¼ 'CROSS_REVIEW_{agent}.md' íŒŒì¼ì— ì‘ì„±í•´ì£¼ì„¸ìš”.\n00178| \"\"\"\n00179|         \n00180|         cross_reviews = []\n00181|         for i, result in enumerate(results):\n00182|             if not result[\"success\"]:\n00183|                 continue\n00184|             \n00185|             agent = result[\"agent\"]\n00186|             other_results = [r for r in results if r[\"agent\"] != agent and r[\"success\"]]\n00187|             \n00188|             if not other_results:\n00189|                 continue\n00190|             \n00191|             other_summary = \"\\n\\n\".join([\n00192|                 f\"[{r['agent']}ì˜ ê²°ê³¼]\\n{r['output'][:500]}...\"\n00193|                 for r in other_results\n00194|             ])\n00195|             \n00196|             prompt = review_prompt.format(other_results=other_summary)\n00197|             review = self.call_agent(agent, prompt)\n00198|             cross_reviews.append(review)\n00199|             \n00200|             status = \"âœ…\" if review[\"success\"] else \"âŒ\"\n00201|             print(f\"{status} {agent} cross-review completed\")\n00202|         \n00203|         return {\"reviews\": cross_reviews}\n00204|     \n00205|     def consensus(self, results: List[Dict], cross_reviews: Dict) -> Dict:\n00206|         \"\"\"í•©ì˜ - ìµœì¢… í†µí•© ì˜ê²¬ ë„ì¶œ\"\"\"\n00207|         print(\"\\n\" + \"=\"*60)\n00208|         print(\"  ğŸ¤ CONSENSUS PHASE\")\n00209|         print(\"=\"*60)\n00210|         \n00211|         consensus_prompt = \"\"\"\n00212| 3ëª…ì˜ ì—ì´ì „íŠ¸ê°€ ì‘ì—…í•œ ê²°ê³¼ì™€ í¬ë¡œìŠ¤ ë¦¬ë·°ë¥¼ ì¢…í•©í•˜ì—¬:\n00213| \n00214| [ì›ë³¸ ì‘ì—… ê²°ê³¼]\n00215| {original_results}\n00216| \n00217| [í¬ë¡œìŠ¤ ë¦¬ë·° ê²°ê³¼]\n00218| {cross_review_summary}\n00219| \n00220| ë‹¤ìŒì„ ìˆ˜í–‰:\n00221| 1. ê°€ì¥ ìš°ìˆ˜í•œ ì ‘ê·¼ ë°©ì‹ ì„ íƒ\n00222| 2. ëª¨ë“  ì—ì´ì „íŠ¸ì˜ ì¢‹ì€ ì•„ì´ë””ì–´ í†µí•©\n00223| 3. ë°œê²¬ëœ ë¬¸ì œì  í•´ê²°\n00224| 4. ìµœì¢… í†µí•© ë²„ì „ ìƒì„±\n00225| \n00226| ìµœì¢… ê²°ê³¼ë¥¼ 'CONSENSUS_RESULT.md'ì— ì‘ì„±í•˜ê³ ,\n00227| í•„ìš”í•œ ì½”ë“œ íŒŒì¼ë“¤ì„ ìƒì„±í•´ì£¼ì„¸ìš”.\n00228| \"\"\"\n00229|         \n00230|         # ê²°ê³¼ ìš”ì•½\n00231|         original_summary = \"\\n\\n\".join([\n00232|             f\"[{r['agent']}]\\n{r['output'][:300]}...\"\n00233|             for r in results if r[\"success\"]\n00234|         ])\n00235|         \n00236|         review_summary = \"\\n\\n\".join([\n00237|             f\"[Review by {r['agent']}]\\n{r['output'][:300]}...\"\n00238|             for r in cross_reviews.get(\"reviews\", []) if r[\"success\"]\n00239|         ])\n00240|         \n00241|         prompt = consensus_prompt.format(\n00242|             original_results=original_summary,\n00243|             cross_review_summary=review_summary\n00244|         )\n00245|         \n00246|         # Agent1ì´ ìµœì¢… í†µí•© (ë¦¬ë” ì—­í• )\n00247|         consensus = self.call_agent(\"agent1\", prompt)\n00248|         \n00249|         status = \"âœ…\" if consensus[\"success\"] else \"âŒ\"\n00250|         print(f\"{status} Consensus reached\")\n00251|         \n00252|         return consensus\n00253|     \n00254|     def execute(self, task: str):\n00255|         \"\"\"ë©”ì¸ ì‹¤í–‰ ë¡œì§\"\"\"\n00256|         print(\"\\n\" + \"=\"*70)\n00257|         print(\"  ğŸ§  SMART ORCHESTRATOR - Intelligent Task Distribution\")\n00258|         print(\"=\"*70)\n00259|         print(f\"\\n[TASK] {task}\\n\")\n00260|         \n00261|         # 1. ë³µì¡ë„ ë¶„ì„\n00262|         needs_parallel = self.analyze_complexity(task)\n00263|         \n00264|         if not needs_parallel:\n00265|             # ë‹¨ìˆœ ì‘ì—… - í˜¼ì ì²˜ë¦¬\n00266|             print(\"\\nğŸ’¡ Simple task detected - Using single agent\")\n00267|             result = self.execute_single(task)\n00268|             \n00269|             if result[\"success\"]:\n00270|                 print(\"\\nâœ… Task completed successfully!\")\n00271|             else:\n00272|                 print(\"\\nâŒ Task failed!\")\n00273|             \n00274|             return result\n00275|         \n00276|         else:\n00277|             # ë³µì¡í•œ ì‘ì—… - ë³‘ë ¬ ì²˜ë¦¬ + í¬ë¡œìŠ¤ì²´í¬ + í•©ì˜\n00278|             print(\"\\nğŸ’¡ Complex task detected - Using parallel mode with consensus\")\n00279|             \n00280|             # Phase 1: ë³‘ë ¬ ì‹¤í–‰\n00281|             results = self.execute_parallel(task)\n00282|             \n00283|             # Phase 2: í¬ë¡œìŠ¤ ë¦¬ë·°\n00284|             cross_reviews = self.cross_review(results)\n00285|             \n00286|             # Phase 3: í•©ì˜ ë° í†µí•©\n00287|             consensus = self.consensus(results, cross_reviews)\n00288|             \n00289|             if consensus[\"success\"]:\n00290|                 print(\"\\n\" + \"=\"*70)\n00291|                 print(\"  âœ… CONSENSUS REACHED - Task Completed\")\n00292|                 print(\"=\"*70)\n00293|                 print(\"\\nğŸ“„ Check these files:\")\n00294|                 print(\"  - CONSENSUS_RESULT.md (ìµœì¢… í†µí•© ê²°ê³¼)\")\n00295|                 print(\"  - CROSS_REVIEW_*.md (í¬ë¡œìŠ¤ ë¦¬ë·°)\")\n00296|                 print(\"  - Generated code files\")\n00297|             else:\n00298|                 print(\"\\nâŒ Consensus failed!\")\n00299|             \n00300|             return {\n00301|                 \"parallel_results\": results,\n00302|                 \"cross_reviews\": cross_reviews,\n00303|                 \"consensus\": consensus\n00304|             }\n00305| \n00306| def main():\n00307|     if len(sys.argv) < 2:\n00308|         print(\"Usage: python smart_orchestrator.py \\\"<task description>\\\"\")\n00309|         print(\"\\nExamples:\")\n00310|         print(\"  Simple:  python smart_orchestrator.py \\\"ê°„ë‹¨í•œ hello í•¨ìˆ˜ ë§Œë“¤ê¸°\\\"\")\n00311|         print(\"  Complex: python smart_orchestrator.py \\\"JWT ì¸ì¦ ì‹œìŠ¤í…œ ì „ì²´ ê²€í†  ë° ë³´ì•ˆ ë¶„ì„\\\"\")\n00312|         sys.exit(1)\n00313|     \n00314|     task = \" \".join(sys.argv[1:])\n00315|     orchestrator = SmartOrchestrator()\n00316|     orchestrator.execute(task)\n00317| \n00318| if __name__ == \"__main__\":\n00319|     main()\n\n(End of file - total 319 lines)\n</file>",
    "title": "app/smart_orchestrator.py",
    "metadata": {
      "preview": "import subprocess\nimport sys\nimport time\nimport json\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom typing import List, Dict, Tuple\n\nclass SmartOrchestrator:\n    \"\"\"ì§€ëŠ¥í˜• ì‘ì—… ë¶„ë°° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°\"\"\"\n    \n    # ë³‘ë ¬ ì²˜ë¦¬ê°€ í•„ìš”í•œ ì‘ì—… í‚¤ì›Œë“œ\n    PARALLEL_KEYWORDS = [\n        \"ê²€í† \", \"ë¦¬ë·°\", \"review\", \"ë¶„ì„\", \"analyze\", \"ê³„íš\", \"plan\",\n        \"ì„¤ê³„\", \"design\", \"ì•„í‚¤í…ì²˜\", \"architecture\",\n        \"ë³´ì•ˆ\", \"security\", \"ì·¨ì•½ì \", \"vulnerability\",\n        \"ì„±ëŠ¥\", \"performance\", \"ìµœì í™”\", \"optimize\",\n        \"í…ŒìŠ¤íŠ¸\", \"test\", \"í’ˆì§ˆ\", \"quality\",\n        \"í’€ìŠ¤íƒ\", \"full-stack\", \"ì „ì²´\", \"complete\",\n        \"ë³µì¡\", \"complex\", \"ëŒ€ê·œëª¨\", \"large-scale\"\n    ]",
      "truncated": false
    },
    "time": {
      "start": 1768184750552,
      "end": 1768184750576
    }
  }
}