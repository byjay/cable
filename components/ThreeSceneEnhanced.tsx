import React, { useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { Node, DeckConfig } from '../types';\nimport { RoutingService } from '../services/routingService';\n\ninterface ThreeSceneProps {\n  nodes: Node[];\n  highlightPath?: string[];\n  deckHeights: DeckConfig;\n  routingService?: RoutingService;\n  showLevelMap?: boolean;\n}\n\nconst ThreeScene: React.FC<ThreeSceneProps> = ({ \n  nodes, \n  highlightPath, \n  deckHeights, \n  routingService,\n  showLevelMap = false \n}) => {\n  const mountRef = useRef<HTMLDivElement>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\n  const controlsRef = useRef<OrbitControls | null>(null);\n  const objectsRef = useRef<THREE.Object3D[]>([]);\n  const [currentLevel, setCurrentLevel] = useState<number>(0);\n  const [levelData, setLevelData] = useState<any>(null);\n\n  // Calculate positions\n  const processedNodes = useRef<Map<string, { x: number, y: number, z: number, level: number }>>(new Map());\n\n  // Deterministic random position based on string\n  const hashString = (str: string) => {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      hash = str.charCodeAt(i) + ((hash << 5) - hash);\n    }\n    return hash;\n  }\n\n  const generateNodePositions = () => {\n    processedNodes.current.clear();\n\n    // Scale factor for real-world coordinates (ship coordinates are in mm, scale down)\n    const SCALE = 0.001;\n\n    // Check if we have real coordinates\n    const hasRealCoords = nodes.some(n => (n.x && n.x !== 0) || (n.y && n.y !== 0) || (n.z && n.z !== 0));\n\n    if (hasRealCoords) {\n      console.log('ðŸŒ Using REAL coordinates from POINT column');\n\n      // Find bounds for auto-centering\n      let minX = Infinity, maxX = -Infinity;\n      let minY = Infinity, maxY = -Infinity;\n      let minZ = Infinity, maxZ = -Infinity;\n\n      nodes.forEach(n => {\n        if (n.x) { minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); }\n        if (n.y) { minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); }\n        if (n.z) { minZ = Math.min(minZ, n.z); maxZ = Math.max(maxZ, n.z); }\n      });\n\n      const centerX = (minX + maxX) / 2;\n      const centerY = (minY + maxY) / 2;\n      const centerZ = (minZ + maxZ) / 2;\n\n      // Calculate level thresholds\n      const zCoords = nodes\n        .filter(n => n.z !== undefined && n.z !== null)\n        .map(n => n.z!)\n        .sort((a, b) => a - b);\n\n      const levelCount = Math.ceil(zCoords.length / 10);\n      const levelThresholds: { [level: number]: { min: number; max: number } } = {};\n      \n      for (let i = 0; i < levelCount; i++) {\n        const startIdx = i * 10;\n        const endIdx = Math.min((i + 1) * 10 - 1, zCoords.length - 1);\n        \n        levelThresholds[i] = {\n          min: zCoords[startIdx] || 0,\n          max: zCoords[endIdx] || zCoords[zCoords.length - 1]\n        };\n      }\n\n      const getLevel = (z: number): number => {\n        for (const [level, threshold] of Object.entries(levelThresholds)) {\n          if (z >= threshold.min && z <= threshold.max) {\n            return parseInt(level);\n          }\n        }\n        return 0;\n      };\n\n      nodes.forEach(node => {\n        if (node.x !== undefined && node.y !== undefined && node.z !== undefined) {\n          const level = getLevel(node.z);\n          // Center and scale coordinates\n          processedNodes.current.set(node.name, {\n            x: (node.x - centerX) * SCALE,\n            y: (node.z - centerZ) * SCALE, // Z becomes Y (height) in Three.js\n            z: (node.y - centerY) * SCALE,  // Y becomes Z in Three.js\n            level\n          });\n        }\n      });\n    } else {\n      console.log('ðŸ“ Using GRID layout (no real coordinates)');\n\n      // Fallback: Group nodes by deck for grid layout\n      const nodesByDeck: { [key: string]: Node[] } = {};\n      nodes.forEach(n => {\n        // Safe deck name extraction\n        const d = n.deck || (n.name && n.name.length > 2 ? n.name.substring(0, 2) : 'UNK');\n        if (!nodesByDeck[d]) nodesByDeck[d] = [];\n        nodesByDeck[d].push(n);\n      });\n\n      // Sort decks to have logical stacking?\n      const sortedDecks = Object.keys(nodesByDeck).sort();\n\n      sortedDecks.forEach((deckName, deckIdx) => {\n        const deckNodes = nodesByDeck[deckName];\n\n        // Vertical spacing between decks\n        const baseHeight = deckIdx * 50;\n\n        // Grid Calculation\n        const cols = Math.ceil(Math.sqrt(deckNodes.length));\n        const spacing = 40; // Increased spacing for better visibility\n\n        deckNodes.forEach((node, i) => {\n          const row = Math.floor(i / cols);\n          const col = i % cols;\n\n          // Deterministic jitter to look more 'organic' but stable\n          const jitterX = ((hashString(node.name) % 100) - 50) / 100;\n          const jitterZ = ((hashString(node.name + 'z') % 100) - 50) / 100;\n\n          processedNodes.current.set(node.name, {\n            x: (col - cols / 2) * spacing + jitterX * 10,\n            y: baseHeight,\n            z: (row - cols / 2) * spacing + jitterZ * 10,\n            level: deckIdx\n          });\n        });\n      });\n    }\n  };\n\n  const createLevelVisualization = (scene: THREE.Scene) => {\n    if (!routingService || !showLevelMap) return;\n\n    // Clear existing level visualization\n    const existingLevelObjects = scene.children.filter(child => child.userData.isLevelVisualization);\n    existingLevelObjects.forEach(obj => scene.remove(obj));\n\n    const levelMapData = routingService.getLevelMapData();\n    \n    // Create level separators\n    Object.keys(levelMapData).forEach(level => {\n      const levelNum = parseInt(level);\n      if (isNaN(levelNum)) return; // Skip 'interLevel'\n\n      const levelInfo = levelMapData[levelNum];\n      \n      // Create level plane\n      const planeGeometry = new THREE.PlaneGeometry(100, 100);\n      const planeMaterial = new THREE.MeshBasicMaterial({\n        color: new THREE.Color(0x444444),\n        transparent: true,\n        opacity: 0.1,\n        side: THREE.DoubleSide\n      });\n      \n      const plane = new THREE.Mesh(planeGeometry, planeMaterial);\n      plane.rotation.x = -Math.PI / 2;\n      plane.position.y = levelNum * 50; // Adjust based on your level spacing\n      plane.userData.isLevelVisualization = true;\n      scene.add(plane);\n\n      // Create level connections\n      levelInfo.connections.forEach((conn: any) => {\n        const fromNode = processedNodes.current.get(conn.source);\n        const toNode = processedNodes.current.get(conn.target);\n        \n        if (fromNode && toNode && fromNode.level === levelNum && toNode.level === levelNum) {\n          const points = [\n            new THREE.Vector3(fromNode.x, fromNode.y, fromNode.z),\n            new THREE.Vector3(toNode.x, toNode.y, toNode.z)\n          ];\n          \n          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n          const lineMaterial = new THREE.LineBasicMaterial({\n            color: new THREE.Color(0x00ff00),\n            linewidth: conn.strokeWidth || 1\n          });\n          \n          const line = new THREE.Line(lineGeometry, lineMaterial);\n          line.userData.isLevelVisualization = true;\n          scene.add(line);\n        }\n      });\n    });\n\n    // Create inter-level connections\n    if (levelMapData.interLevel) {\n      levelMapData.interLevel.forEach((conn: any) => {\n        const fromNode = processedNodes.current.get(conn.source);\n        const toNode = processedNodes.current.get(conn.target);\n        \n        if (fromNode && toNode) {\n          const points = [\n            new THREE.Vector3(fromNode.x, fromNode.y, fromNode.z),\n            new THREE.Vector3(toNode.x, toNode.y, toNode.z)\n          ];\n          \n          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n          const lineMaterial = new THREE.LineBasicMaterial({\n            color: new THREE.Color(conn.color || 0xff0000),\n            linewidth: 2\n          });\n          \n          const line = new THREE.Line(lineGeometry, lineMaterial);\n          line.userData.isLevelVisualization = true;\n          scene.add(line);\n        }\n      });\n    }\n  };\n\n  useEffect(() => {\n    if (!mountRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x1a1a1a);\n    sceneRef.current = scene;\n\n    // Camera setup\n    const camera = new THREE.PerspectiveCamera(\n      75,\n      mountRef.current.clientWidth / mountRef.current.clientHeight,\n      0.1,\n      1000\n    );\n    camera.position.set(50, 50, 50);\n    cameraRef.current = camera;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    mountRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Controls\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controlsRef.current = controls;\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    scene.add(ambientLight);\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\n    directionalLight.position.set(10, 10, 5);\n    scene.add(directionalLight);\n\n    // Generate node positions\n    generateNodePositions();\n\n    // Create nodes\n    nodes.forEach(node => {\n      const pos = processedNodes.current.get(node.name);\n      if (!pos) return;\n\n      // Node sphere\n      const geometry = new THREE.SphereGeometry(1, 16, 16);\n      const material = new THREE.MeshPhongMaterial({\n        color: highlightPath?.includes(node.name) ? 0x00ff00 : 0x0088ff\n      });\n      const sphere = new THREE.Mesh(geometry, material);\n      sphere.position.set(pos.x, pos.y, pos.z);\n      sphere.userData = { node, name: node.name };\n      scene.add(sphere);\n      objectsRef.current.push(sphere);\n\n      // Node label\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d')!;\n      canvas.width = 256;\n      canvas.height = 64;\n      context.fillStyle = 'white';\n      context.font = '24px Arial';\n      context.fillText(node.name, 10, 40);\n\n      const texture = new THREE.CanvasTexture(canvas);\n      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });\n      const sprite = new THREE.Sprite(spriteMaterial);\n      sprite.position.set(pos.x, pos.y + 3, pos.z);\n      sprite.scale.set(8, 2, 1);\n      scene.add(sprite);\n      objectsRef.current.push(sprite);\n    });\n\n    // Create level visualization\n    createLevelVisualization(scene);\n\n    // Animation loop\n    const animate = () => {\n      requestAnimationFrame(animate);\n      controls.update();\n      renderer.render(scene, camera);\n    };\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      if (!mountRef.current) return;\n      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n    };\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (mountRef.current && renderer.domElement) {\n        mountRef.current.removeChild(renderer.domElement);\n      }\n      renderer.dispose();\n    };\n  }, [nodes, highlightPath, deckHeights, routingService, showLevelMap]);\n\n  // Update level visualization when showLevelMap changes\n  useEffect(() => {\n    if (sceneRef.current) {\n      createLevelVisualization(sceneRef.current);\n    }\n  }, [showLevelMap, currentLevel]);\n\n  return (\n    <div style={{ position: 'relative', width: '100%', height: '100%' }}>\n      <div ref={mountRef} style={{ width: '100%', height: '100%' }} />\n      {showLevelMap && (\n        <div style={{ position: 'absolute', top: 10, left: 10, background: 'rgba(0,0,0,0.7)', padding: '10px', borderRadius: '5px' }}>\n          <div style={{ color: 'white', fontSize: '12px' }}>\n            <div>Level Map Mode</div>\n            <div>Current Level: {currentLevel}</div>\n            <button \n              onClick={() => setCurrentLevel(prev => prev + 1)}\n              style={{ marginTop: '5px', padding: '5px 10px' }}\n            >\n              Next Level\n            </button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default ThreeScene;
